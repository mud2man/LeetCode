/* Union Find: Time:O(n^2), Space:O(n). LeetCode has DFS solution
 * 1. Delete all nodes and its edges from initial, use union and find to construct componets with identity root[i], and record the componet size by size[i] 
 * 2. Get component2Malwares to learn what malwares in each component
 * 3. Get the spred size w.r.t. malware, which has only one malware impact the component
 * 4. Return the malware with the maximum spreding area
 */

import java.util.*;

/* Definition for binary tree */
public class Solution {
    private int find(int[] roots, int x){
        if(roots[x] == x){
            return x;
        }
        else{
            //compression
            roots[x] = roots[roots[x]];
            return find(roots, roots[x]);
        }
    }
    
    public int minMalwareSpread(int[][] graph, int[] initial) {
        Set<Integer> malwares = new HashSet<>();
        for(int i: initial){
            malwares.add(i);
        }
        
        int[] roots = new int[graph.length];
        int[] size = new int[graph.length];
        int[] rank = new int[graph.length];
        for(int i = 0; i < roots.length; ++i){
            roots[i] = i; 
            size[i] = 1;
        }
        
        for(int y = 1; y < graph.length; ++y){
            for(int x = 0; x < y && !malwares.contains(y); ++x){
                if(malwares.contains(x) || graph[y][x] == 0){
                    continue;
                }
                //union by rank
                int rootY = find(roots, y);
                int rootX = find(roots, x);
                if(rootY != rootX){
                    if(rank[rootY] == rank[rootX]){
                        roots[rootX] = rootY;
                        rank[rootY]++;
                        size[rootY] = size[rootY] + size[rootX];
                    }
                    else if(rank[rootY] > rank[rootX]){
                        roots[rootX] = rootY;
                        size[rootY] = size[rootY] + size[rootX];
                    }
                    else{
                        roots[rootY] = rootX;
                        size[rootX] = size[rootY] + size[rootX];
                    }
                }
            }
        }
        
        Map<Integer, Set<Integer>> component2Malwares = new HashMap<>();
        for(int malware: malwares){
            for(int x = 0; x < graph.length; ++x){
                if(graph[malware][x] == 1 && !malwares.contains(x)){
                    int component = find(roots, x);
                    component2Malwares.putIfAbsent(component, new HashSet<>());
                    component2Malwares.get(component).add(malware);
                }
            }
        }
        
        int candidate = initial[0];
        int max = 0;
        for(int malware: malwares){
            int spredSize = 0;
            for(int x = 0; x < graph.length; ++x){
                if(graph[malware][x] == 1 && !malwares.contains(x)){
                    int component = find(roots, x);
                    if(component2Malwares.get(component).size() == 1){
                       spredSize += size[component];
                    }
                }
            }
            if(spredSize > max){
                candidate = malware;
                max = spredSize;
            }
            else if(spredSize == max){
                candidate = (malware < candidate)? malware: candidate;
            }
        }
        return candidate;
    }
  
    public static void main(String[] args){
        Solution sol = new Solution();
        int[][] graph = {{1, 1, 0}, {1, 1, 1}, {0, 1, 1}};
        int[] initial = {0, 1};
        System.out.println("graph: ");
        for(int[] row: graph){
            System.out.println(Arrays.toString(row));
        }
        System.out.println("initial:" + Arrays.toString(initial));
        System.out.println("critical node: " + sol.minMalwareSpread(graph, initial));
    }
}
