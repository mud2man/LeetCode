/* Union Find: Time:O(n^2), Space:O(n). We can also use DFS solution
 * 1. Use union and find to construct componets with identity root[i], and record the componet size by size[i] 
 * 2. Get root2Initials to learn what initials in each component
 * 3. Select the initial which it's the only initial in the component, and with the component's size is the biggest
 */

import java.util.*;

/* Definition for binary tree */
public class Solution {
    private int find(int[] roots, int x){
        if(roots[x] == x){
            return x;
        }
        //cpmpression
        roots[x] = roots[roots[x]];
        return find(roots, roots[roots[x]]);
    }
    
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int length = graph.length;
        int[] roots = new int[length];
        int[] rank = new int[length];
        int[] size = new int[length];
        for(int i = 0; i < length; ++i){
            roots[i] = i;
            size[i] = 1;
        }
        
        for(int y = 1; y < length; ++y){
            for(int x = 0; x < y; ++x){
                if(graph[y][x] == 1){
                    int root0 = find(roots, y);
                    int root1 = find(roots, x);
                    //union by rank
                    if(root0 != root1){
                        if(rank[root0] == rank[root1]){
                            roots[root1] = root0;
                            rank[root0]++;
                            size[root0] = size[root0] + size[root1];
                        }else if(rank[root0] > rank[root1]){
                            roots[root1] = root0;
                            size[root0] = size[root0] + size[root1];
                        }else{
                            roots[root0] = root1;
                            size[root1] = size[root0] + size[root1];
                        }
                    }
                }
            }
        }
        
        Map<Integer, Set<Integer>> root2Initials = new HashMap<>();
        int candidate = length + 1;
        for(int malware: initial){
            //get the smallest initial
            candidate = Math.min(candidate, malware);
            int root = find(roots, malware);
            root2Initials.computeIfAbsent(root, key -> new HashSet<>()).add(malware);
        }
        
        int max = 0;
        for(int malware: initial){
            int root = find(roots, malware);
            if(root2Initials.get(root).size() == 1){
                if(max == size[root]){
                    candidate = Math.min(candidate, malware);
                }else if(max < size[root]){
                    candidate = malware;
                    max = size[root];
                }
            }
        }
        return candidate;
    }
  
    public static void main(String[] args){
        Solution sol = new Solution();
        int[][] graph = {{1, 1, 0}, {1, 1, 0}, {0, 0, 1}};
        int[] initial = {0, 1};
        System.out.println("graph: ");
        for(int[] row: graph){
            System.out.println(Arrays.toString(row));
        }
        System.out.println("initial:" + Arrays.toString(initial));
        System.out.println("critical node: " + sol.minMalwareSpread(graph, initial));
    }
}
